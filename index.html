<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <link rel="icon" type="image/png" href="./icon512.png" />
    <link rel="manifest" href="./manifest.json" />
    <title>Story Reader PWA</title>

    <style>
      :root {
        --bar-height: 56px;
        --max-width: 980px;
        --accent: #0f172a;
        --muted: #5b6170;
        --sidebar-width: 300px;
        --card: #f8fafc;
        --shadow: 0 12px 36px rgba(15, 23, 42, 0.12);
        --reader-font-size: 16px;
      }

      html, body {
        height: 100%;
        margin: 0;
        font-family: "Inter", "Segoe UI", system-ui, -apple-system, Roboto, "Helvetica Neue", Arial, sans-serif;
        color: var(--accent);
        background: linear-gradient(180deg, #f3f6fb 0%, #ffffff 22%, #f9fbff 100%);
      }

      header.topbar {
        position: fixed;
        inset: 0 0 auto 0;
        height: var(--bar-height);
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 0 14px;
        box-sizing: border-box;
        background: rgba(255, 255, 255, 0.92);
        backdrop-filter: blur(6px);
        border-bottom: 1px solid rgba(15, 23, 42, 0.06);
        z-index: 30;
      }

      button#menu-toggle {
        appearance: none;
        border: 0;
        background: transparent;
        padding: 8px;
        display: inline-grid;
        place-items: center;
        cursor: pointer;
        border-radius: 8px;
        transition: background 160ms ease;
      }
      button#menu-toggle:hover { background: rgba(15, 23, 42, 0.06); }
      button#menu-toggle:focus { outline: 2px solid rgba(15, 23, 42, 0.14); }

      .hamburger {
        width: 20px;
        height: 2px;
        background: var(--accent);
        position: relative;
      }
      .hamburger::before, .hamburger::after {
        content: "";
        position: absolute;
        left: 0;
        width: 20px;
        height: 2px;
        background: var(--accent);
      }
      .hamburger::before { top: -6px; }
      .hamburger::after { top: 6px; }

      .audio-toggle {
        margin-left: 4px;
        font-size: 13px;
        letter-spacing: 0.01em;
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }
      .audio-toggle .dot {
        display: inline-block;
        width: 8px;
        height: 8px;
        border-radius: 999px;
        background: rgba(15, 23, 42, 0.16);
      }
      .audio-toggle.playing .dot { background: #22c55e; }

      .topbar-actions {
        margin-left: auto;
        display: inline-flex;
        align-items: center;
        gap: 10px;
      }
      .pill-button {
        appearance: none;
        border: 1px solid rgba(15, 23, 42, 0.12);
        background: #fff;
        color: var(--accent);
        border-radius: 999px;
        padding: 8px 12px;
        font-size: 13px;
        cursor: pointer;
        transition: background 140ms ease, box-shadow 140ms ease, transform 140ms ease;
        box-shadow: 0 4px 16px rgba(15, 23, 42, 0.06);
      }
      .pill-button:hover { background: rgba(15, 23, 42, 0.06); transform: translateY(-1px); }
      .pill-button:disabled { opacity: 0.55; cursor: not-allowed; transform: none; box-shadow: none; }
      .pill-button:focus { outline: 2px solid rgba(15, 23, 42, 0.18); outline-offset: 2px; }

      .level-stepper {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 4px 6px;
        border-radius: 12px;
        background: rgba(15, 23, 42, 0.05);
        border: 1px solid rgba(15, 23, 42, 0.08);
      }
      .step-btn {
        appearance: none;
        border: 0;
        background: #fff;
        color: var(--accent);
        border-radius: 8px;
        padding: 6px 10px;
        font-size: 14px;
        cursor: pointer;
        box-shadow: 0 2px 8px rgba(15, 23, 42, 0.08);
        transition: background 140ms ease, transform 140ms ease;
      }
      .step-btn:hover { background: rgba(15, 23, 42, 0.08); transform: translateY(-1px); }
      .step-btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; box-shadow: none; }
      .step-btn:focus { outline: 2px solid rgba(15, 23, 42, 0.18); outline-offset: 2px; }

      aside.sidebar {
        position: fixed;
        top: 0;
        left: 0;
        height: 100vh;
        width: var(--sidebar-width);
        transform: translateX(-100%);
        transition: transform 220ms ease;
        background: #fff;
        box-shadow: var(--shadow);
        z-index: 40;
        padding: calc(var(--bar-height) - 5px) 16px 24px;
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
        gap: 12px;
        overflow-y: auto;
      }
      aside.sidebar.open { transform: translateX(0); }

      button#sidebar-close {
        appearance: none;
        border: 0;
        background: transparent;
        padding: 8px;
        cursor: pointer;
        border-radius: 6px;
        position: absolute;
        top: 10px;
        right: 10px;
      }

      nav.menu {
        display: flex;
        flex-direction: column;
        gap: 8px;
        margin: 10px 0 6px;
      }
      nav.menu a {
        color: var(--accent);
        text-decoration: none;
        font-size: 14px;
        padding: 8px 10px;
        border-radius: 8px;
        background: rgba(15, 23, 42, 0.04);
        transition: background 140ms ease;
      }
      nav.menu a:hover { background: rgba(15, 23, 42, 0.08); }

      .sidebar-section {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      .sidebar-brand {
        margin-bottom: 6px;
        padding: 6px 4px 2px;
      }
      .sidebar-brand .brand-title {
        font-size: 18px;
        font-weight: 700;
        letter-spacing: 0.05em;
      }
      .sidebar-brand .brand-subtitle {
        font-size: 12px;
        color: var(--muted);
        margin-top: 2px;
      }
      .controls-row {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      label.small {
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        color: var(--muted);
      }

      select {
        height: 38px;
        font-size: 14px;
        padding: 0 10px;
        border-radius: 10px;
        border: 1px solid rgba(15, 23, 42, 0.08);
        background: #fff;
        color: var(--accent);
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.02);
      }
      select:disabled { color: rgba(15, 23, 42, 0.4); background: rgba(15, 23, 42, 0.03); }
      .bookmark-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: center;
      }
      .bookmark-status {
        font-size: 12px;
        color: var(--muted);
      }

      .sidebar-footer {
        margin-top: auto;
        padding: 12px 10px 10px;
        font-size: 12px;
        color: var(--muted);
        border-top: 1px solid rgba(15, 23, 42, 0.08);
        background: #fff;
        line-height: 1.4;
      }
      .sidebar-footer .version-line { font-weight: 600; color: var(--accent); }
      .sidebar-footer .updated-line { margin-top: 2px; }
      .sidebar-footer .cache-line { margin-top: 2px; font-style: italic; }

      .overlay {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.24);
        opacity: 0;
        pointer-events: none;
        transition: opacity 180ms ease;
        z-index: 35;
      }
      .overlay.show {
        opacity: 1;
        pointer-events: auto;
      }

      main.reader {
        min-height: calc(100vh - var(--bar-height));
        display: flex;
        align-items: flex-start;
        justify-content: center;
        padding: calc(var(--bar-height) + 24px) 16px 32px;
        box-sizing: border-box;
      }

      .reader-panel {
        width: 100%;
        max-width: var(--max-width);
        background: #fff;
        border-radius: 14px;
        padding: 22px 22px 28px;
        box-shadow: var(--shadow);
        box-sizing: border-box;
      }

      .reader-head {
        margin-bottom: 14px;
      }
      .eyebrow {
        font-size: 12px;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: var(--muted);
        margin-bottom: 6px;
      }
      #reader-title {
        margin: 0;
        font-size: clamp(22px, 4vw, 34px);
        line-height: 1.2;
        color: var(--accent);
      }

      .markdown-body {
        color: var(--accent);
        font-size: var(--reader-font-size);
        line-height: 1.6;
      }
      .markdown-body h1,
      .markdown-body h2,
      .markdown-body h3 {
        margin: 18px 0 10px;
      }
      .markdown-body p {
        margin: 10px 0;
      }
      .markdown-body ul {
        padding-left: 18px;
        margin: 10px 0;
      }

      .catalog-book {
        margin-bottom: 18px;
        padding: 12px;
        border-radius: 10px;
        background: var(--card);
      }
      .catalog-book h3 {
        margin: 0 0 6px;
      }
      .catalog-meta {
        color: var(--muted);
        font-size: 13px;
        margin-bottom: 8px;
      }
      .chip {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 6px 10px;
        border-radius: 999px;
        border: 1px solid rgba(15, 23, 42, 0.08);
        background: #fff;
        font-size: 13px;
        margin: 4px 6px 4px 0;
        cursor: pointer;
      }
      .chip:hover { background: rgba(15, 23, 42, 0.06); }

      .status-line {
        margin-top: 14px;
        font-size: 13px;
        color: var(--muted);
      }
      .next-chapter {
        margin-top: 18px;
        display: flex;
        flex-direction: row;
        justify-content: space-between;
        gap: 12px;
        align-items: center;
      }
      .next-chapter .next-chapter-right {
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        gap: 4px;
      }
      .next-chapter-meta {
        font-size: 12px;
        color: var(--muted);
      }
      .comprehension {
        margin-top: 18px;
        padding: 12px;
        border-radius: 12px;
        background: var(--card);
        border: 1px solid rgba(15, 23, 42, 0.08);
      }
      .comprehension-title {
        font-size: 14px;
        font-weight: 600;
        margin-bottom: 8px;
      }
      .comprehension-question {
        margin-bottom: 10px;
      }
      .comprehension-question legend {
        font-size: 13px;
        margin-bottom: 6px;
      }
      .comprehension-options {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .comprehension-status {
        margin-top: 6px;
        font-size: 13px;
        color: var(--muted);
      }

      /* Night mode overrides */
      html.night, body.night {
        --accent: #e5e7eb;
        --muted: #94a3b8;
        --card: #0f172a;
        --shadow: 0 12px 36px rgba(0, 0, 0, 0.55);
        color: var(--accent);
        background: #0b1220;
      }
      body.night main.reader { background: #0b1220; }
      body.night header.topbar {
        background: rgba(15, 23, 42, 0.94);
        border-bottom: 1px solid rgba(148, 163, 184, 0.22);
      }
      body.night .hamburger,
      body.night .hamburger::before,
      body.night .hamburger::after {
        background: var(--accent);
      }
      body.night aside.sidebar {
        background: #0f172a;
        box-shadow: var(--shadow);
      }
      body.night .sidebar-brand .brand-subtitle {
        color: var(--muted);
      }
      body.night .sidebar-footer {
        background: #0f172a;
        border-top: 1px solid rgba(148, 163, 184, 0.22);
      }
      body.night nav.menu a {
        background: rgba(226, 232, 240, 0.08);
      }
      body.night nav.menu a:hover { background: rgba(226, 232, 240, 0.12); }
      body.night .reader-panel {
        background: #0f172a;
        box-shadow: var(--shadow);
      }
      body.night select {
        background: #1f2937;
        border-color: rgba(148, 163, 184, 0.35);
        color: var(--accent);
      }
      body.night .chip,
      body.night .pill-button,
      body.night .step-btn {
        background: #1f2937;
        border-color: rgba(148, 163, 184, 0.35);
        color: var(--accent);
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
      }
      body.night .pill-button:hover,
      body.night .step-btn:hover {
        background: rgba(226, 232, 240, 0.08);
      }
      body.night .level-stepper {
        background: rgba(226, 232, 240, 0.05);
        border-color: rgba(148, 163, 184, 0.28);
      }
      body.night .catalog-book {
        background: #0f172a;
        box-shadow: var(--shadow);
      }

      @media (min-width: 900px) {
        aside.sidebar { width: 320px; --sidebar-width: 320px; }
        .reader-panel { padding: 26px 28px 34px; }
      }

      /* Floating Button Styles */
      .floating-btn {
        position: fixed;
        bottom: 80px;
        right: 20px;
        width: 56px;
        height: 56px;
        border-radius: 50%;
        background: rgba(102, 126, 234, 0.35);
        backdrop-filter: blur(8px);
        -webkit-backdrop-filter: blur(8px);
        border: 2px solid rgba(102, 126, 234, 0.5);
        color: #667eea;
        font-size: 18px;
        font-weight: 700;
        cursor: grab;
        box-shadow: 0 2px 12px rgba(102, 126, 234, 0.2);
        z-index: 50;
        display: flex;
        align-items: center;
        justify-content: center;
        touch-action: none;
        user-select: none;
        transition: transform 140ms ease, box-shadow 140ms ease, background 140ms ease;
      }
      .floating-btn:hover {
        transform: scale(1.05);
        background: rgba(102, 126, 234, 0.5);
        box-shadow: 0 4px 16px rgba(102, 126, 234, 0.3);
      }
      .floating-btn:active, .floating-btn.dragging {
        cursor: grabbing;
        transform: scale(0.95);
      }
      .floating-btn.hidden {
        display: none;
      }
      body.night .floating-btn {
        background: rgba(102, 126, 234, 0.25);
        border-color: rgba(102, 126, 234, 0.4);
        color: #a5b4fc;
      }
      body.night .floating-btn:hover {
        background: rgba(102, 126, 234, 0.4);
      }

      /* Word Translation Popup */
      .word-translation-popup {
        position: absolute;
        background: #fff;
        border-radius: 10px;
        padding: 10px 14px;
        box-shadow: 0 4px 24px rgba(15, 23, 42, 0.18);
        z-index: 100;
        max-width: 300px;
        min-width: 140px;
        pointer-events: none;
        opacity: 0;
        transform: translateY(5px);
        transition: opacity 150ms ease, transform 150ms ease;
        font-size: 14px;
        line-height: 1.5;
      }
      .word-translation-popup.visible {
        opacity: 1;
        transform: translateY(0);
      }
      .word-translation-popup::after {
        content: '';
        position: absolute;
        bottom: -6px;
        left: 50%;
        transform: translateX(-50%);
        border-left: 6px solid transparent;
        border-right: 6px solid transparent;
        border-top: 6px solid #fff;
      }
      .word-translation-popup .popup-word {
        font-weight: 700;
        color: #667eea;
        font-size: 15px;
        margin-bottom: 4px;
      }
      .word-translation-popup .popup-definition {
        color: var(--accent);
        font-size: 13px;
        margin-bottom: 6px;
      }
      .word-translation-popup .popup-translation {
        font-size: 13px;
        color: #059669;
        font-weight: 500;
        padding-top: 6px;
        border-top: 1px solid rgba(0,0,0,0.08);
      }
      .word-translation-popup .popup-info {
        font-size: 11px;
        color: var(--muted);
        margin-top: 4px;
      }
      .word-translation-popup .popup-loading {
        color: var(--muted);
        font-style: italic;
      }
      body.night .word-translation-popup {
        background: #1f2937;
        box-shadow: 0 4px 24px rgba(0, 0, 0, 0.35);
      }
      body.night .word-translation-popup::after {
        border-top-color: #1f2937;
      }
      body.night .word-translation-popup .popup-word {
        color: #a5b4fc;
      }
      body.night .word-translation-popup .popup-definition {
        color: #e5e7eb;
      }
      body.night .word-translation-popup .popup-translation {
        color: #34d399;
        border-top-color: rgba(255,255,255,0.1);
      }

      /* Text selection styling for translation lookup */
      #story-body ::selection {
        background: rgba(102, 126, 234, 0.3);
      }
      body.night #story-body ::selection {
        background: rgba(102, 126, 234, 0.4);
      }
    </style>
  </head>
  <body>
    <header class="topbar" role="banner">
      <button id="menu-toggle" aria-controls="site-sidebar" aria-expanded="false" aria-label="Open menu">
        <span class="hamburger" aria-hidden="true"></span>
      </button>
      <button type="button" id="audio-toggle" class="pill-button audio-toggle" disabled aria-pressed="false" aria-label="Play audio">
        <span class="dot" aria-hidden="true"></span>
        <span class="label">Play audio</span>
      </button>
      <div class="topbar-actions" aria-label="Quick language controls">
        <button type="button" id="lang-toggle" class="pill-button" aria-label="Toggle language">English</button>
        <div class="level-stepper" role="group" aria-label="Change reading level">
          <button type="button" id="level-down" class="step-btn" aria-label="Previous level">-</button>
          <button type="button" id="level-up" class="step-btn" aria-label="Next level">+</button>
        </div>
      </div>
    </header>

    <aside id="site-sidebar" class="sidebar" role="dialog" aria-hidden="true" aria-label="Site menu">
      <button id="sidebar-close" aria-label="Close menu">‚úï</button>

      <div class="sidebar-brand">
        <div class="brand-title">VIŒõ Fabula</div>
        <div class="brand-subtitle">Language learning via stories</div>
      </div>

      <div class="sidebar-section" aria-hidden="false">
        <div class="controls-row">
          <label for="book-select" class="small">Story</label>
          <select id="book-select" aria-label="Select story"></select>
        </div>

        <div class="controls-row">
          <label for="chapter-select" class="small">Chapter</label>
          <select id="chapter-select" aria-label="Select chapter"></select>
        </div>

        <div class="controls-row">
          <label for="level-select" class="small">Level</label>
          <select id="level-select" aria-label="Select level"></select>
        </div>

        <div class="controls-row">
          <label for="native-lang-select" class="small">Native language</label>
          <select id="native-lang-select" aria-label="Select native language"></select>
        </div>

        <div class="controls-row">
          <label for="learning-lang-select" class="small">Learning language</label>
          <select id="learning-lang-select" aria-label="Select learning language"></select>
        </div>

        <div class="controls-row">
          <label for="text-size-select" class="small">Text size</label>
          <select id="text-size-select" aria-label="Select text size">
            <option value="small">Small</option>
            <option value="medium">Medium</option>
            <option value="large">Large</option>
            <option value="xlarge">Extra large</option>
          </select>
        </div>

        <div class="controls-row">
          <label class="small">Bookmark</label>
          <div class="bookmark-actions">
            <button type="button" id="save-bookmark" class="pill-button">Save bookmark</button>
            <button type="button" id="go-bookmark" class="pill-button">Open bookmark</button>
            <div id="bookmark-status" class="bookmark-status">No bookmark saved.</div>
          </div>
        </div>

        <div class="controls-row">
          <label class="small" for="theme-toggle">Night mode</label>
          <button type="button" id="theme-toggle" class="pill-button" aria-pressed="false">Off</button>
        </div>

        <div class="controls-row">
          <label class="small" for="floating-btn-toggle">Floating button</label>
          <button type="button" id="floating-btn-toggle" class="pill-button" aria-pressed="false">Off</button>
        </div>
      </div>

      <nav class="menu" aria-label="Links">
        <a href="#" id="book-catalog-link">Book catalog</a>
        <a href="#" id="about-link">About</a>
      </nav>

      <div class="sidebar-footer" aria-live="polite">
        <div id="footer-version" class="version-line">Version 0.1</div>
        <div id="footer-updated" class="updated-line">Last updated ‚Äî</div>
        <div id="footer-cache" class="cache-line">Checking‚Ä¶</div>
      </div>
    </aside>

    <div id="overlay" class="overlay" tabindex="-1" aria-hidden="true"></div>

    <main class="reader" role="main">
      <article class="reader-panel" id="reader">
        <header class="reader-head">
          <div class="eyebrow" id="reader-meta">Loading‚Ä¶</div>
          <h1 id="reader-title">Story reader</h1>
        </header>
        <div class="markdown-body" id="story-body" aria-live="polite">
          Choose a story, chapter, level, and languages from the menu.
        </div>
        <div class="comprehension" id="comprehension" hidden>
          <div class="comprehension-title">Reading comprehension</div>
          <div class="comprehension-body" id="comprehension-body"></div>
          <div class="comprehension-status" id="comprehension-status"></div>
        </div>
        <div class="next-chapter" id="next-chapter">
          <button type="button" id="prev-chapter-button" class="pill-button">Previous chapter</button>
          <div class="next-chapter-right">
            <button type="button" id="next-chapter-button" class="pill-button">Next chapter</button>
            <div class="next-chapter-meta" id="next-chapter-meta"></div>
          </div>
        </div>
        <div class="status-line" id="status-line" role="status"></div>
      </article>
    </main>

    <!-- Floating Multifunctional Button -->
    <button type="button" id="floating-btn" class="floating-btn hidden" aria-label="Toggle language">
      <span id="floating-btn-label">üåê</span>
    </button>

    <!-- Word Translation Popup -->
    <div id="word-translation-popup" class="word-translation-popup" aria-live="polite" aria-hidden="true">
      <div class="popup-word" id="popup-word"></div>
      <div class="popup-definition" id="popup-definition"></div>
      <div class="popup-translation" id="popup-translation" style="display:none;"></div>
      <div class="popup-info" id="popup-info"></div>
    </div>

    <script src="./converter.js"></script>
    <script>
      if ('serviceWorker' in navigator) {
        const swScope = './';
        const swUrl = './sw.js';
        let refreshing = false;

        navigator.serviceWorker.register(swUrl, { scope: swScope }).then((registration) => {
          const sendSkipWaiting = (worker) => {
            if (worker) worker.postMessage({ type: 'SKIP_WAITING' });
          };

          // If there's a waiting worker when we register, activate it.
          if (registration.waiting) sendSkipWaiting(registration.waiting);

          registration.addEventListener('updatefound', () => {
            const newWorker = registration.installing;
            if (!newWorker) return;
            newWorker.addEventListener('statechange', () => {
              if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                sendSkipWaiting(newWorker);
              }
            });
          });

          // Reload once when the new service worker activates.
          navigator.serviceWorker.addEventListener('controllerchange', () => {
            if (refreshing) return;
            refreshing = true;
            window.location.reload();
          });

          // Proactively check for updates on load.
          registration.update().catch(() => {/* ignore update errors */});
        }).catch(() => {/* ignore registration errors */});
      }

      const menuToggle = document.getElementById('menu-toggle');
      const sidebar = document.getElementById('site-sidebar');
      const overlay = document.getElementById('overlay');
      const sidebarClose = document.getElementById('sidebar-close');
      const audioToggleBtn = document.getElementById('audio-toggle');
      const audioToggleLabel = audioToggleBtn?.querySelector('.label');
      const langToggleBtn = document.getElementById('lang-toggle');
      const levelUpBtn = document.getElementById('level-up');
      const levelDownBtn = document.getElementById('level-down');

      function openSidebar() {
        sidebar.classList.add('open');
        sidebar.setAttribute('aria-hidden', 'false');
        menuToggle.setAttribute('aria-expanded', 'true');
        overlay.classList.add('show');
        overlay.setAttribute('aria-hidden', 'false');
      }
      function closeSidebar() {
        sidebar.classList.remove('open');
        sidebar.setAttribute('aria-hidden', 'true');
        menuToggle.setAttribute('aria-expanded', 'false');
        overlay.classList.remove('show');
        overlay.setAttribute('aria-hidden', 'true');
      }

      menuToggle.addEventListener('click', () => {
        const expanded = menuToggle.getAttribute('aria-expanded') === 'true';
        if (expanded) closeSidebar(); else openSidebar();
      });
      overlay.addEventListener('click', closeSidebar);
      sidebarClose.addEventListener('click', closeSidebar);
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') closeSidebar();
      });
      if (audioToggleBtn) audioToggleBtn.addEventListener('click', toggleAudioPlayback);

      const bookSelect = document.getElementById('book-select');
      const chapterSelect = document.getElementById('chapter-select');
      const levelSelect = document.getElementById('level-select');
      const nativeLangSelect = document.getElementById('native-lang-select');
      const learningLangSelect = document.getElementById('learning-lang-select');
      const readerTitle = document.getElementById('reader-title');
      const readerMeta = document.getElementById('reader-meta');
      const readerPanel = document.getElementById('reader');
      const storyBody = document.getElementById('story-body');
      const statusLine = document.getElementById('status-line');
      const catalogLink = document.getElementById('book-catalog-link');
      const aboutLink = document.getElementById('about-link');
      const themeToggle = document.getElementById('theme-toggle');
      const footerVersion = document.getElementById('footer-version');
      const footerUpdated = document.getElementById('footer-updated');
      const footerCache = document.getElementById('footer-cache');
      const nextChapterContainer = document.getElementById('next-chapter');
      const prevChapterButton = document.getElementById('prev-chapter-button');
      const nextChapterButton = document.getElementById('next-chapter-button');
      const nextChapterMeta = document.getElementById('next-chapter-meta');
      const comprehensionSection = document.getElementById('comprehension');
      const comprehensionBody = document.getElementById('comprehension-body');
      const comprehensionStatus = document.getElementById('comprehension-status');
      const textSizeSelect = document.getElementById('text-size-select');
      const saveBookmarkBtn = document.getElementById('save-bookmark');
      const goBookmarkBtn = document.getElementById('go-bookmark');
      const bookmarkStatus = document.getElementById('bookmark-status');
      const floatingBtn = document.getElementById('floating-btn');
      const floatingBtnLabel = document.getElementById('floating-btn-label');
      const floatingBtnToggle = document.getElementById('floating-btn-toggle');
      const wordTranslationPopup = document.getElementById('word-translation-popup');
      const popupWord = document.getElementById('popup-word');
      const popupDefinition = document.getElementById('popup-definition');
      const popupTranslation = document.getElementById('popup-translation');
      const popupInfo = document.getElementById('popup-info');

      const SETTINGS_KEY = 'reader-settings';
      const SETTINGS_DEFAULT = {
        nativeLanguageId: 'english',
        learningLanguageId: null,
        theme: 'light',
        textSize: 'medium',
        bookmark: null,
        floatingButtonEnabled: false,
        floatingButtonPosition: null,
      };
      const TEXT_SIZE_MAP = {
        small: '15px',
        medium: '16px',
        large: '18px',
        xlarge: '20px',
      };
      const FALLBACK_NATIVE_ID = 'english';
      let library = { books: [] };
      const state = { bookId: null, chapterId: null, langId: null, levelId: null };
      let userSettings = SETTINGS_DEFAULT;
      let nativeLanguageId = SETTINGS_DEFAULT.nativeLanguageId;
      let learningLanguageId = null;
      let textSize = SETTINGS_DEFAULT.textSize;
      let nightMode = false;
      let bookmark = null;
      let floatingButtonEnabled = false;
      let floatingButtonPosition = null;
      let cachedOtherLangContent = null;
      let cachedOtherLangId = null;
      const LAST_VERSION_KEY = 'reader-last-version';
      const LAST_VISIT_KEY = 'reader-last-visit';
      const MANUAL_VERSION = '0.1'; // set to e.g. "0.1" to override auto version labeling
      const BUILD_INFO = (() => {
        const parsed = new Date(document.lastModified);
        const validDate = Number.isNaN(parsed.getTime()) ? new Date() : parsed;
        const iso = validDate.toISOString();
        const autoVersion = `v${iso.slice(0, 16).replace('T', ' ')}`; // vYYYY-MM-DD HH:MM
        const version = MANUAL_VERSION || autoVersion;
        return { version, publishedAt: iso };
      })();
      let prevChapterTarget = null;
      let nextChapterTarget = null;
      let questionsRequired = false;
      let comprehensionComplete = true;
      let comprehensionQuestions = [];
      let comprehensionAnswers = {};
      let audioPlayer = null;
      let audioReady = false;
      let audioRequestId = 0;

      function readUserSettings() {
        try {
          const stored = JSON.parse(localStorage.getItem(SETTINGS_KEY) || 'null');
          if (!stored || typeof stored !== 'object') return { ...SETTINGS_DEFAULT };
          return { ...SETTINGS_DEFAULT, ...stored };
        } catch (err) {
          return { ...SETTINGS_DEFAULT };
        }
      }
      function persistSettings(patch = {}) {
        userSettings = { ...userSettings, ...patch };
        localStorage.setItem(SETTINGS_KEY, JSON.stringify(userSettings));
      }
      function primeSettingsFromStorage() {
        userSettings = readUserSettings();
        nativeLanguageId = userSettings.nativeLanguageId || FALLBACK_NATIVE_ID;
        learningLanguageId = userSettings.learningLanguageId || null;
        nightMode = userSettings.theme === 'dark';
        textSize = userSettings.textSize || SETTINGS_DEFAULT.textSize;
        bookmark = normalizeBookmark(userSettings.bookmark);
        floatingButtonEnabled = userSettings.floatingButtonEnabled || false;
        floatingButtonPosition = userSettings.floatingButtonPosition || null;
      }
      function applyTextSize() {
        const size = TEXT_SIZE_MAP[textSize] || TEXT_SIZE_MAP.medium;
        document.documentElement.style.setProperty('--reader-font-size', size);
        if (textSizeSelect) textSizeSelect.value = TEXT_SIZE_MAP[textSize] ? textSize : 'medium';
      }

      primeSettingsFromStorage();

      const escapeHtml = (text = '') => text
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/\"/g, '&quot;')
        .replace(/'/g, '&#39;');



      function markdownToHtml(mdText) {
        const trimmed = (mdText || '').trim();
        if (!trimmed) return '<p>Empty file.</p>';
        const blocks = trimmed.split(/\n\s*\n/);

        const blockHtml = blocks.map((block) => {
          const lines = block.split('\n');
          const first = lines[0];

          if (/^#{1,6}\s+/.test(first)) {
            const level = Math.min(6, first.match(/^#+/)[0].length);
            const headingText = escapeHtml(first.replace(/^#{1,6}\s+/, '').trim());
            const rest = lines.slice(1).map(escapeHtml).join('<br>');
            return `<h${level}>${headingText}</h${level}>${rest ? `<p>${rest}</p>` : ''}`;
          }

          const isList = lines.every(line => /^[-*]\s+/.test(line.trim()));
          if (isList) {
            const items = lines.map(line => `<li>${escapeHtml(line.replace(/^[-*]\s+/, '').trim())}</li>`).join('');
            return `<ul>${items}</ul>`;
          }

          return `<p>${lines.map(escapeHtml).join('<br>')}</p>`;
        });

        return blockHtml.join('');
      }

      function setStatus(text) {
        statusLine.textContent = text || '';
      }

      function scrollReaderToTop() {
        if (readerPanel && typeof readerPanel.scrollIntoView === 'function') {
          readerPanel.scrollIntoView({ block: 'start', behavior: 'smooth' });
        } else {
          window.scrollTo({ top: 0, behavior: 'smooth' });
        }
      }

      function updateScrollTopVisibility() {
        scrollReaderToTop();
      }

      function updateAudioButton() {
        if (!audioToggleBtn) return;
        const isPlaying = audioReady && audioPlayer && !audioPlayer.paused && !audioPlayer.ended;
        const labelText = audioReady ? (isPlaying ? 'Pause audio' : 'Play audio') : 'Audio unavailable';
        audioToggleBtn.disabled = !audioReady;
        audioToggleBtn.classList.toggle('playing', isPlaying);
        audioToggleBtn.setAttribute('aria-pressed', String(isPlaying));
        audioToggleBtn.setAttribute('aria-label', labelText);
        if (audioToggleLabel) audioToggleLabel.textContent = labelText;
      }
      function resetAudio() {
        if (audioPlayer) {
          audioPlayer.pause();
          audioPlayer.src = '';
        }
        audioPlayer = null;
        audioReady = false;
        updateAudioButton();
      }
      function deriveAudioPath(levelPath) {
        if (!levelPath) return null;
        const normalized = levelPath.replace(/\\/g, '/');
        if (normalized.endsWith('.md') || normalized.endsWith('.txt')) {
          return normalized.replace(/\.[^.]+$/, '.wav');
        }
        return null;
      }
      async function prepareAudio(level) {
        resetAudio();
        if (!level) return;
        const wavPath = deriveAudioPath(level.path);
        if (!wavPath) return;
        const requestId = ++audioRequestId;
        try {
          const response = await fetch(wavPath, { method: 'HEAD' });
          if (requestId !== audioRequestId) return;
          if (!response.ok) return;
        } catch (err) {
          if (requestId !== audioRequestId) return;
          return;
        }
        if (requestId !== audioRequestId) return;
        audioPlayer = new Audio(wavPath);
        audioPlayer.preload = 'metadata';
        audioReady = true;
        audioPlayer.addEventListener('play', updateAudioButton);
        audioPlayer.addEventListener('pause', updateAudioButton);
        audioPlayer.addEventListener('ended', updateAudioButton);
        updateAudioButton();
      }
      function toggleAudioPlayback() {
        if (!audioReady || !audioPlayer) return;
        if (audioPlayer.paused || audioPlayer.ended) {
          if (audioPlayer.ended) audioPlayer.currentTime = 0;
          audioPlayer.play().then(updateAudioButton).catch(() => {
            audioPlayer.pause();
            updateAudioButton();
          });
        } else {
          audioPlayer.pause();
          updateAudioButton();
        }
      }

      function setSelectOptions(select, items, currentValue) {
        select.innerHTML = '';
        items.forEach((item) => {
          const option = document.createElement('option');
          option.value = item.id;
          option.textContent = item.title || item.id;
          select.appendChild(option);
        });
        select.disabled = items.length === 0;
        if (items.length === 0) return null;
        const nextValue = items.find(item => item.id === currentValue)?.id || items[0].id;
        select.value = nextValue;
        return nextValue;
      }

      function findBook() {
        return library.books.find(book => book.id === state.bookId) || null;
      }
      function findChapter() {
        return findBook()?.chapters.find(ch => ch.id === state.chapterId) || null;
      }
      function findLanguage() {
        return findChapter()?.languages.find(l => l.id === state.langId) || null;
      }
      function findLevel() {
        return findLanguage()?.levels.find(lv => lv.id === state.levelId) || null;
      }
      function availableLanguages() {
        return findChapter()?.languages || [];
      }
      function findPrevChapterSelection() {
        const book = findBook();
        if (!book) return null;
        const chapters = book.chapters || [];
        const idx = chapters.findIndex(ch => ch.id === state.chapterId);
        if (idx === -1) return null;
        for (let i = idx - 1; i >= 0; i -= 1) {
          const candidate = chapters[i];
          const lang = candidate.languages.find(l => l.id === state.langId);
          if (!lang) continue;
          const level = lang.levels.find(lv => lv.id === state.levelId);
          if (!level) continue;
          return {
            chapterId: candidate.id,
            chapterTitle: candidate.title,
            langId: lang.id,
            levelId: level.id,
            langTitle: lang.title,
            levelTitle: level.title,
          };
        }
        return null;
      }
      function findNextChapterSelection() {
        const book = findBook();
        if (!book) return null;
        const chapters = book.chapters || [];
        const idx = chapters.findIndex(ch => ch.id === state.chapterId);
        if (idx === -1) return null;
        for (let i = idx + 1; i < chapters.length; i += 1) {
          const candidate = chapters[i];
          const lang = candidate.languages.find(l => l.id === state.langId);
          if (!lang) continue;
          const level = lang.levels.find(lv => lv.id === state.levelId);
          if (!level) continue;
          return {
            chapterId: candidate.id,
            chapterTitle: candidate.title,
            langId: lang.id,
            levelId: level.id,
            langTitle: lang.title,
            levelTitle: level.title,
          };
        }
        return null;
      }
      function resetComprehension() {
        questionsRequired = false;
        comprehensionComplete = true;
        comprehensionQuestions = [];
        comprehensionAnswers = {};
        if (comprehensionSection) comprehensionSection.hidden = true;
        if (comprehensionBody) comprehensionBody.innerHTML = '';
        if (comprehensionStatus) comprehensionStatus.textContent = '';
      }
      function evaluateComprehension() {
        if (!questionsRequired || !comprehensionQuestions.length) {
          comprehensionComplete = true;
          updateChapterNav();
          return;
        }
        const allAnswered = comprehensionQuestions.every(q => typeof comprehensionAnswers[q.id] === 'number');
        if (!allAnswered) {
          comprehensionComplete = false;
          if (comprehensionStatus) comprehensionStatus.textContent = 'Answer all questions to unlock the next chapter.';
          updateChapterNav();
          return;
        }
        const allCorrect = comprehensionQuestions.every(q => comprehensionAnswers[q.id] === Number(q.correctIndex));
        comprehensionComplete = allCorrect;
        if (comprehensionStatus) {
          comprehensionStatus.textContent = allCorrect
            ? 'Great! Next chapter unlocked.'
            : 'Some answers are incorrect. Try again.';
        }
        updateChapterNav();
      }
      function renderComprehensionQuestions(questions) {
        if (!comprehensionSection || !comprehensionBody || !questions.length) return;
        comprehensionBody.innerHTML = '';
        questions.forEach((q, idx) => {
          const fieldset = document.createElement('fieldset');
          fieldset.className = 'comprehension-question';
          const legend = document.createElement('legend');
          legend.textContent = `${idx + 1}. ${q.question}`;
          fieldset.appendChild(legend);

          const optionsWrap = document.createElement('div');
          optionsWrap.className = 'comprehension-options';
          (q.options || []).forEach((opt, optIdx) => {
            const label = document.createElement('label');
            const input = document.createElement('input');
            input.type = 'radio';
            input.name = `comp-${q.id}`;
            input.value = String(optIdx);
            input.addEventListener('change', () => {
              comprehensionAnswers[q.id] = Number(optIdx);
              evaluateComprehension();
            });
            label.appendChild(input);
            label.appendChild(document.createTextNode(` ${opt}`));
            optionsWrap.appendChild(label);
          });
          fieldset.appendChild(optionsWrap);
          comprehensionBody.appendChild(fieldset);
        });
        comprehensionSection.hidden = false;
        if (comprehensionStatus) comprehensionStatus.textContent = 'Answer all questions to unlock the next chapter.';
      }
      async function loadComprehensionQuestions(level) {
        resetComprehension();
        if (!level?.path || !comprehensionSection) {
          updateChapterNav();
          return;
        }
        const qPath = level.path.replace(/\.md$/, '_q.json');
        try {
          const response = await fetch(qPath, { cache: 'no-cache' });
          if (!response.ok) throw new Error(`No questions at ${qPath}`);
          const data = await response.json();
          const questions = Array.isArray(data.questions) ? data.questions : [];
          if (!questions.length) {
            updateChapterNav();
            return;
          }
          questionsRequired = true;
          comprehensionComplete = false;
          comprehensionQuestions = questions.map(q => ({
            ...q,
            correctIndex: Number(q.correctIndex),
          }));
          renderComprehensionQuestions(questions);
          updateChapterNav();
        } catch (error) {
          resetComprehension();
          updateChapterNav();
        }
      }
      function getLanguageTitleById(langId) {
        return availableLanguages().find(lang => lang.id === langId)?.title || langId || 'Language';
      }
      function ensureLanguageSelections() {
        const available = availableLanguages();
        if (!available.length) {
          nativeLanguageId = null;
          learningLanguageId = null;
          state.langId = null;
          return;
        }
        if (!available.some(lang => lang.id === nativeLanguageId)) {
          nativeLanguageId = available.find(lang => lang.id === FALLBACK_NATIVE_ID)?.id || available[0].id;
        }
        if (available.length > 1 && learningLanguageId === nativeLanguageId) {
          const alt = available.find(lang => lang.id !== nativeLanguageId);
          if (alt) learningLanguageId = alt.id;
        }
        if (!available.some(lang => lang.id === learningLanguageId)) {
          const fallback = available.find(lang => lang.id !== nativeLanguageId);
          learningLanguageId = fallback ? fallback.id : nativeLanguageId;
        }
        if (!available.some(lang => lang.id === state.langId)) {
          state.langId = learningLanguageId || nativeLanguageId;
        }
        if (nativeLangSelect) nativeLangSelect.value = nativeLanguageId;
        if (learningLangSelect) learningLangSelect.value = learningLanguageId;
      }
      function updateLangToggleButton() {
        if (!langToggleBtn) return;
        const available = availableLanguages();
        const hasNative = available.some(lang => lang.id === nativeLanguageId);
        const hasLearning = learningLanguageId && available.some(lang => lang.id === learningLanguageId);
        const canToggle = hasNative && hasLearning && learningLanguageId !== nativeLanguageId;
        const currentTitle = getLanguageTitleById(state.langId) || 'Language';
        const defaultTitle = getLanguageTitleById(nativeLanguageId) || 'Native language';
        const learningTitle = learningLanguageId ? getLanguageTitleById(learningLanguageId) : null;

        langToggleBtn.textContent = currentTitle;
        const otherTitle = state.langId === nativeLanguageId ? (learningTitle || currentTitle) : defaultTitle;
        langToggleBtn.setAttribute('aria-label', `Toggle language between ${defaultTitle} and ${otherTitle}`);
        langToggleBtn.disabled = !canToggle;
      }
      function updateLevelButtons() {
        if (!levelUpBtn || !levelDownBtn) return;
        const levels = findLanguage()?.levels || [];
        const idx = levels.findIndex(level => level.id === state.levelId);
        const invalid = idx === -1 || levels.length === 0;
        levelDownBtn.disabled = invalid || idx === 0;
        levelUpBtn.disabled = invalid || idx === levels.length - 1;
      }
      function updateChapterNav() {
        if (!nextChapterContainer || !nextChapterButton || !nextChapterMeta || !prevChapterButton) return;
        const next = findNextChapterSelection();
        const prev = findPrevChapterSelection();
        nextChapterTarget = next;
        prevChapterTarget = prev;

        const locked = questionsRequired && !comprehensionComplete;
        const enableNext = !!next && !locked;
        const enablePrev = !!prev;

        nextChapterButton.disabled = !enableNext;
        prevChapterButton.disabled = !enablePrev;

        nextChapterButton.textContent = enableNext ? `Next: ${next.chapterTitle}` : 'Next chapter';
        nextChapterButton.setAttribute('aria-label', enableNext
          ? `Next chapter ${next.chapterTitle}`
          : 'Next chapter');
        nextChapterMeta.textContent = '';
        nextChapterMeta.hidden = true;

        prevChapterButton.setAttribute('aria-label', enablePrev ? `Previous chapter ${prev.chapterTitle}` : 'Previous chapter');
      }
      function normalizeBookmark(raw) {
        if (!raw || typeof raw !== 'object') return null;
        const { bookId, chapterId, langId, levelId } = raw;
        if (!bookId || !chapterId || !langId || !levelId) return null;
        return { bookId, chapterId, langId, levelId };
      }
      function bookmarkIsValid(bm) {
        const normalized = normalizeBookmark(bm);
        if (!normalized) return false;
        const book = library.books.find(b => b.id === normalized.bookId);
        if (!book) return false;
        const chapter = book.chapters.find(ch => ch.id === normalized.chapterId);
        if (!chapter) return false;
        const lang = chapter.languages.find(l => l.id === normalized.langId);
        if (!lang) return false;
        const level = lang.levels.find(lv => lv.id === normalized.levelId);
        return !!level;
      }
      function updateBookmarkStatus() {
        if (!bookmarkStatus) return;
        if (bookmark && !library.books.length) {
          bookmarkStatus.textContent = 'Loading bookmark‚Ä¶';
          if (goBookmarkBtn) goBookmarkBtn.disabled = true;
          return;
        }
        if (!bookmarkIsValid(bookmark)) {
          bookmarkStatus.textContent = 'No bookmark saved.';
          if (goBookmarkBtn) goBookmarkBtn.disabled = true;
          return;
        }
        const book = library.books.find(b => b.id === bookmark.bookId);
        const chapter = book?.chapters.find(ch => ch.id === bookmark.chapterId);
        const lang = chapter?.languages.find(l => l.id === bookmark.langId);
        const level = lang?.levels.find(lv => lv.id === bookmark.levelId);
        const label = [book?.title, chapter?.title, lang?.title, level?.title].filter(Boolean).join(' ¬∑ ');
        bookmarkStatus.textContent = label || 'Bookmark ready.';
        if (goBookmarkBtn) goBookmarkBtn.disabled = false;
      }
      function saveBookmark() {
        const nextBookmark = normalizeBookmark(state);
        if (!nextBookmark) return;
        bookmark = nextBookmark;
        persistSettings({ bookmark });
        updateBookmarkStatus();
      }
      function openBookmark() {
        if (!bookmarkIsValid(bookmark)) return;
        state.bookId = bookmark.bookId;
        state.chapterId = bookmark.chapterId;
        state.langId = bookmark.langId;
        learningLanguageId = bookmark.langId;
        state.levelId = bookmark.levelId;
        populateBooks();
        persistSettings({ bookmark, learningLanguageId });
      }
      function refreshQuickControls() {
        ensureLanguageSelections();
        updateLangToggleButton();
        updateLevelButtons();
        updateChapterNav();
      }
      function stepLevel(direction) {
        const levels = findLanguage()?.levels || [];
        if (!levels.length) return;
        const currentIndex = levels.findIndex(level => level.id === state.levelId);
        if (currentIndex === -1) return;
        const nextIndex = direction === 'up'
          ? Math.min(levels.length - 1, currentIndex + 1)
          : Math.max(0, currentIndex - 1);
        if (nextIndex === currentIndex) return;
        state.levelId = levels[nextIndex].id;
        levelSelect.value = state.levelId;
        loadCurrentSelection();
        updateLevelButtons();
      }
      function toggleLanguage() {
        const available = availableLanguages();
        if (!available.length) return;
        ensureLanguageSelections();
        const targetLangId = state.langId === nativeLanguageId
          ? (learningLanguageId || nativeLanguageId)
          : nativeLanguageId;
        if (!available.some(lang => lang.id === targetLangId)) return;
        state.langId = targetLangId;
        populateLevels();
        persistSettings({ nativeLanguageId, learningLanguageId });
        if (typeof onLanguageChangeCallback === 'function') {
          onLanguageChangeCallback();
        }
      }
      let onLanguageChangeCallback = null;
      function formatDateTime(isoString) {
        const date = new Date(isoString);
        if (Number.isNaN(date.getTime())) return isoString;
        return date.toLocaleString(undefined, { dateStyle: 'medium', timeStyle: 'short' });
      }
      function updateVersionFooter() {
        if (!footerVersion || !footerUpdated || !footerCache) return;
        footerVersion.textContent = `Version ${BUILD_INFO.version}`;
        footerUpdated.textContent = `Last updated ${formatDateTime(BUILD_INFO.publishedAt)}`;

        const previousVersion = localStorage.getItem(LAST_VERSION_KEY);
        const previousVisit = localStorage.getItem(LAST_VISIT_KEY);
        if (previousVersion && previousVersion !== BUILD_INFO.version) {
          const seen = previousVisit ? ` (seen ${formatDateTime(previousVisit)})` : '';
          footerCache.textContent = `New since last visit (${previousVersion}${seen})`;
        } else if (!navigator.onLine) {
          footerCache.textContent = 'Offline ‚Äî may be a cached version';
        } else {
          footerCache.textContent = 'Up to date';
        }

        localStorage.setItem(LAST_VERSION_KEY, BUILD_INFO.version);
        localStorage.setItem(LAST_VISIT_KEY, new Date().toISOString());
      }
      function applyTheme() {
        document.body.classList.toggle('night', nightMode);
        document.documentElement.classList.toggle('night', nightMode);
        if (themeToggle) {
          themeToggle.textContent = nightMode ? 'On' : 'Off';
          themeToggle.setAttribute('aria-pressed', String(nightMode));
          themeToggle.setAttribute('aria-label', `Night mode ${nightMode ? 'on' : 'off'}`);
        }
      }

      function populateBooks(options = {}) {
        state.bookId = setSelectOptions(bookSelect, library.books, state.bookId);
        populateChapters(options);
      }
      function populateChapters(options = {}) {
        const book = findBook();
        state.chapterId = setSelectOptions(chapterSelect, book?.chapters || [], state.chapterId);
        populateLanguages(options);
      }
      function populateLanguages(options = {}) {
        const chapter = findChapter();
        const languages = chapter?.languages || [];
        nativeLanguageId = setSelectOptions(nativeLangSelect, languages, nativeLanguageId);
        learningLanguageId = setSelectOptions(learningLangSelect, languages, learningLanguageId || state.langId);
        ensureLanguageSelections();
        state.langId = state.langId || learningLanguageId || nativeLanguageId;
        persistSettings({ nativeLanguageId, learningLanguageId, textSize, theme: nightMode ? 'dark' : 'light', bookmark });
        populateLevels(options);
      }
      function populateLevels(options = {}) {
        const language = findLanguage();
        state.levelId = setSelectOptions(levelSelect, language?.levels || [], state.levelId);
        refreshQuickControls();
        loadCurrentSelection(options);
      }

      async function loadCurrentSelection(options = {}) {
        const { scrollToTop = false } = options;
        const book = findBook();
        const chapter = findChapter();
        const lang = findLanguage();
        const level = findLevel();

        if (!book || !chapter || !lang || !level) {
          storyBody.textContent = 'Pick a story, chapter, level, and languages that exist in the catalog.';
          setStatus('Waiting for a valid selection.');
          resetAudio();
          if (nextChapterContainer) nextChapterContainer.hidden = true;
          return;
        }

        readerTitle.textContent = chapter.title;
        readerMeta.textContent = `${book.title} ¬∑ ${lang.title} ¬∑ ${level.title}`;
        prepareAudio(level);

        resetComprehension();
        updateChapterNav();
        if (scrollToTop) scrollReaderToTop();
        setStatus('Loading story‚Ä¶');
        try {
          const response = await fetch(level.path);
          if (!response.ok) throw new Error(`HTTP ${response.status}`);
          const md = await response.text();
          storyBody.innerHTML = markdownToHtml(md);
          setStatus(`Loaded ${lang.title} ¬∑ ${level.title}`);
          await loadComprehensionQuestions(level);
        } catch (error) {
          storyBody.textContent = 'Unable to load this file. Check that it exists and is reachable.';
          setStatus('Failed to load markdown content.');
          console.error(error);
        }
      }

      async function loadLibrary() {
        setStatus('Loading catalog‚Ä¶');
        try {
          const response = await fetch('./content-index.json');
          if (!response.ok) throw new Error(`HTTP ${response.status}`);
          library = await response.json();
        } catch (error) {
          storyBody.textContent = 'Could not read content-index.json. Place it next to index.html to drive the dropdowns.';
          setStatus('Catalog missing or unreadable.');
          console.error(error);
          return;
        }

        if (!library.books?.length) {
          storyBody.textContent = 'No books found in the catalog.';
          setStatus('Add books under content/books to begin.');
          return;
        }

        if (bookmark && !bookmarkIsValid(bookmark)) {
          bookmark = null;
          persistSettings({ bookmark: null });
        }
        if (bookmarkIsValid(bookmark)) {
          state.bookId = bookmark.bookId;
          state.chapterId = bookmark.chapterId;
          state.langId = bookmark.langId;
          learningLanguageId = bookmark.langId;
          state.levelId = bookmark.levelId;
        }

        populateBooks();
        updateBookmarkStatus();
        updateFloatingBtnLabel();
      }

      function renderCatalogView() {
        readerTitle.textContent = 'Book catalog';
        readerMeta.textContent = 'Pick a level to jump into a story';
        resetAudio();
        storyBody.innerHTML = '';
        if (nextChapterContainer) nextChapterContainer.hidden = true;
        setStatus('Tap a language/level to open it.');
        updateScrollTopVisibility();

        if (!library.books.length) {
          storyBody.textContent = 'Catalog is empty.';
          return;
        }

        library.books.forEach((book) => {
          const bookDiv = document.createElement('div');
          bookDiv.className = 'catalog-book';

          const heading = document.createElement('h3');
          heading.textContent = book.title;
          bookDiv.appendChild(heading);

          const meta = document.createElement('div');
          meta.className = 'catalog-meta';
          meta.textContent = `${book.chapters.length} chapter(s)`;
          bookDiv.appendChild(meta);

          book.chapters.forEach((chapter) => {
            const chapterMeta = document.createElement('div');
            chapterMeta.className = 'catalog-meta';
            chapterMeta.textContent = chapter.title;
            bookDiv.appendChild(chapterMeta);

            chapter.languages.forEach((lang) => {
              const langLabel = document.createElement('div');
              langLabel.className = 'catalog-meta';
              langLabel.textContent = lang.title;
              bookDiv.appendChild(langLabel);

              lang.levels.forEach((level) => {
                const chip = document.createElement('button');
                chip.type = 'button';
                chip.className = 'chip';
                chip.textContent = `${lang.title} ¬∑ ${level.title}`;
                chip.addEventListener('click', () => {
                  state.bookId = book.id;
                  populateBooks();
                  state.chapterId = chapter.id;
                  populateChapters();
                  state.langId = lang.id;
                  populateLanguages();
                  state.levelId = level.id;
                  populateLevels();
                  closeSidebar();
                });
                bookDiv.appendChild(chip);
              });
            });
          });

          storyBody.appendChild(bookDiv);
        });
      }

      function renderAboutView() {
        readerTitle.textContent = 'About this reader';
        readerMeta.textContent = 'Offline-friendly PWA';
        resetAudio();
        storyBody.innerHTML = `
          <p>Our aim is simple: bring stories and language learning to everyone. We keep you captivated in a narrative while you move through adaptive levels for quick, self-organized learning.</p>
          <p>Levels run from A0/A1 for brand-new readers, through A2 and B1/B2 for growing confidence, up to C1/C2 native-level text ‚Äî including original-author prose when available.</p>
          <p>It is also a doorway into literature: jump between languages, compare versions, and feel the rhythm of real writing while building fluency.</p>
          <p><strong>Disclaimer:</strong> Many passages are AI-generated or AI-adapted. Treat them as helpful companions, not perfect originals.</p>
        `;
        if (nextChapterContainer) nextChapterContainer.hidden = true;
        setStatus('');
        updateScrollTopVisibility();
      }

      bookSelect.addEventListener('change', () => { state.bookId = bookSelect.value; populateChapters(); });
      chapterSelect.addEventListener('change', () => { state.chapterId = chapterSelect.value; populateLanguages(); });
      nativeLangSelect?.addEventListener('change', () => {
        nativeLanguageId = nativeLangSelect.value;
        ensureLanguageSelections();
        persistSettings({ nativeLanguageId });
        updateLangToggleButton();
      });
      learningLangSelect?.addEventListener('change', () => {
        learningLanguageId = learningLangSelect.value;
        state.langId = learningLanguageId || nativeLanguageId;
        persistSettings({ learningLanguageId });
        populateLevels();
      });
      levelSelect.addEventListener('change', () => {
        state.levelId = levelSelect.value;
        loadCurrentSelection();
        updateLevelButtons();
        closeSidebar();
      });
      langToggleBtn?.addEventListener('click', toggleLanguage);
      levelUpBtn?.addEventListener('click', () => stepLevel('up'));
      levelDownBtn?.addEventListener('click', () => stepLevel('down'));
      themeToggle?.addEventListener('click', () => {
        nightMode = !nightMode;
        applyTheme();
        persistSettings({ theme: nightMode ? 'dark' : 'light' });
      });
      textSizeSelect?.addEventListener('change', () => {
        textSize = textSizeSelect.value;
        persistSettings({ textSize });
        applyTextSize();
      });
      saveBookmarkBtn?.addEventListener('click', () => {
        saveBookmark();
      });
      goBookmarkBtn?.addEventListener('click', () => {
        openBookmark();
        closeSidebar();
      });
      prevChapterButton?.addEventListener('click', () => {
        if (!prevChapterTarget) return;
        state.chapterId = prevChapterTarget.chapterId;
        state.langId = prevChapterTarget.langId;
        state.levelId = prevChapterTarget.levelId;
        populateChapters({ scrollToTop: true });
      });
      nextChapterButton?.addEventListener('click', () => {
        if (!nextChapterTarget) return;
        state.chapterId = nextChapterTarget.chapterId;
        state.langId = nextChapterTarget.langId;
        state.levelId = nextChapterTarget.levelId;
        populateChapters({ scrollToTop: true });
      });

      catalogLink.addEventListener('click', (event) => {
        event.preventDefault();
        renderCatalogView();
        closeSidebar();
      });
      aboutLink.addEventListener('click', (event) => {
        event.preventDefault();
        renderAboutView();
        closeSidebar();
      });

      // ======== Floating Button Functionality ========
      let floatingBtnDragging = false;
      let floatingBtnStartX = 0;
      let floatingBtnStartY = 0;
      let floatingBtnOffsetX = 0;
      let floatingBtnOffsetY = 0;
      let floatingBtnMoved = false;

      function applyFloatingButtonVisibility() {
        if (!floatingBtn || !floatingBtnToggle) return;
        floatingBtn.classList.toggle('hidden', !floatingButtonEnabled);
        floatingBtnToggle.textContent = floatingButtonEnabled ? 'On' : 'Off';
        floatingBtnToggle.setAttribute('aria-pressed', String(floatingButtonEnabled));
        if (floatingButtonEnabled && floatingButtonPosition) {
          floatingBtn.style.left = `${floatingButtonPosition.x}px`;
          floatingBtn.style.top = `${floatingButtonPosition.y}px`;
          floatingBtn.style.right = 'auto';
          floatingBtn.style.bottom = 'auto';
        }
      }

      function toggleFloatingButton() {
        floatingButtonEnabled = !floatingButtonEnabled;
        persistSettings({ floatingButtonEnabled });
        applyFloatingButtonVisibility();
      }

      function updateFloatingBtnLabel() {
        if (!floatingBtnLabel) return;
        const currentLangId = state.langId;
        if (currentLangId && currentLangId.length >= 2) {
          floatingBtnLabel.textContent = currentLangId.substring(0, 2).toUpperCase();
        } else if (currentLangId) {
          floatingBtnLabel.textContent = currentLangId.toUpperCase();
        } else {
          floatingBtnLabel.textContent = 'üåê';
        }
      }

      function floatingBtnTap() {
        toggleLanguage();
        updateFloatingBtnLabel();
      }

      function startDrag(clientX, clientY) {
        if (!floatingBtn) return;
        floatingBtnDragging = true;
        floatingBtnMoved = false;
        const rect = floatingBtn.getBoundingClientRect();
        floatingBtnOffsetX = clientX - rect.left;
        floatingBtnOffsetY = clientY - rect.top;
        floatingBtnStartX = clientX;
        floatingBtnStartY = clientY;
        floatingBtn.classList.add('dragging');
      }

      function moveDrag(clientX, clientY) {
        if (!floatingBtnDragging || !floatingBtn) return;
        const dx = Math.abs(clientX - floatingBtnStartX);
        const dy = Math.abs(clientY - floatingBtnStartY);
        if (dx > 5 || dy > 5) {
          floatingBtnMoved = true;
        }
        let newX = clientX - floatingBtnOffsetX;
        let newY = clientY - floatingBtnOffsetY;
        const maxX = window.innerWidth - floatingBtn.offsetWidth;
        const maxY = window.innerHeight - floatingBtn.offsetHeight;
        newX = Math.max(0, Math.min(newX, maxX));
        newY = Math.max(0, Math.min(newY, maxY));
        floatingBtn.style.left = `${newX}px`;
        floatingBtn.style.top = `${newY}px`;
        floatingBtn.style.right = 'auto';
        floatingBtn.style.bottom = 'auto';
      }

      function endDrag() {
        if (!floatingBtn) return;
        if (floatingBtnDragging) {
          const rect = floatingBtn.getBoundingClientRect();
          floatingButtonPosition = { x: rect.left, y: rect.top };
          persistSettings({ floatingButtonPosition });
        }
        floatingBtnDragging = false;
        floatingBtn.classList.remove('dragging');
      }

      // Floating button event handlers
      if (floatingBtn) {
        floatingBtn.addEventListener('mousedown', (e) => {
          e.preventDefault();
          startDrag(e.clientX, e.clientY);
        });

        floatingBtn.addEventListener('touchstart', (e) => {
          if (e.touches.length === 1) {
            const touch = e.touches[0];
            startDrag(touch.clientX, touch.clientY);
          }
        }, { passive: true });

        document.addEventListener('mousemove', (e) => {
          if (floatingBtnDragging) {
            moveDrag(e.clientX, e.clientY);
          }
        });

        document.addEventListener('touchmove', (e) => {
          if (floatingBtnDragging && e.touches.length === 1) {
            const touch = e.touches[0];
            moveDrag(touch.clientX, touch.clientY);
          }
        }, { passive: true });

        document.addEventListener('mouseup', (e) => {
          if (floatingBtnDragging) {
            endDrag();
            if (!floatingBtnMoved) {
              floatingBtnTap();
            }
          }
        });

        document.addEventListener('touchend', (e) => {
          if (floatingBtnDragging) {
            endDrag();
            if (!floatingBtnMoved) {
              floatingBtnTap();
            }
          }
        });
      }

      floatingBtnToggle?.addEventListener('click', toggleFloatingButton);

      // ======== Text Selection Translation ========
      let wordTranslationTimeout = null;
      const DICTIONARY_API_URL = 'https://api.dictionaryapi.dev/api/v2/entries/en/';

      // Language code mapping for MyMemory translation API
      const LANG_CODES = {
        english: 'en',
        spanish: 'es',
        german: 'de',
        french: 'fr',
        italian: 'it',
        portuguese: 'pt',
        dutch: 'nl',
        russian: 'ru',
        chinese: 'zh',
        japanese: 'ja',
        korean: 'ko'
      };

      function hideWordTranslation() {
        if (wordTranslationPopup) {
          wordTranslationPopup.classList.remove('visible');
          wordTranslationPopup.setAttribute('aria-hidden', 'true');
        }
        if (wordTranslationTimeout) {
          clearTimeout(wordTranslationTimeout);
          wordTranslationTimeout = null;
        }
      }

      async function fetchDefinition(word) {
        try {
          const response = await fetch(`${DICTIONARY_API_URL}${encodeURIComponent(word.toLowerCase())}`);
          if (!response.ok) return null;
          const data = await response.json();
          if (data && data[0] && data[0].meanings && data[0].meanings[0]) {
            const meaning = data[0].meanings[0];
            const partOfSpeech = meaning.partOfSpeech || '';
            const definition = meaning.definitions && meaning.definitions[0] 
              ? meaning.definitions[0].definition 
              : null;
            return { partOfSpeech, definition };
          }
          return null;
        } catch (err) {
          return null;
        }
      }

      async function fetchTranslation(word, targetLangCode) {
        if (!targetLangCode || targetLangCode === 'en') return null;
        try {
          // Use MyMemory translation API (free, no API key required)
          const url = `https://api.mymemory.translated.net/get?q=${encodeURIComponent(word)}&langpair=en|${targetLangCode}`;
          const response = await fetch(url);
          if (!response.ok) return null;
          const data = await response.json();
          if (data && data.responseData && data.responseData.translatedText) {
            const translated = data.responseData.translatedText;
            // Check for error messages from MyMemory
            if (translated.toLowerCase().includes('invalid') || 
                translated.toLowerCase().includes('error') ||
                translated === word) {
              return null;
            }
            return translated;
          }
          return null;
        } catch (err) {
          return null;
        }
      }

      function positionPopupAtRect(rect) {
        const scrollTop = window.scrollY || document.documentElement.scrollTop;
        const scrollLeft = window.scrollX || document.documentElement.scrollLeft;
        
        const popupLeft = rect.left + scrollLeft + (rect.width / 2);
        const popupTop = rect.top + scrollTop - 10;
        
        wordTranslationPopup.style.left = `${popupLeft}px`;
        wordTranslationPopup.style.top = `${popupTop}px`;
        wordTranslationPopup.style.transform = 'translate(-50%, -100%)';
      }

      async function showSelectionDefinition(rect, word, showTranslation = false) {
        if (!wordTranslationPopup || !popupWord || !popupDefinition) return;
        
        hideWordTranslation();
        positionPopupAtRect(rect);
        
        // Get target language info for translation
        const targetLangId = nativeLanguageId || 'english';
        const targetLangCode = LANG_CODES[targetLangId] || 'en';
        const targetLangTitle = getLanguageTitleById(targetLangId);
        
        // Detect source language - if current text is not English, swap translation direction
        const currentLangId = learningLanguageId || selectedLanguageId || 'english';
        const currentLangCode = LANG_CODES[currentLangId] || 'en';
        
        // Show loading state
        popupWord.textContent = word;
        popupDefinition.textContent = 'Looking up...';
        popupTranslation.style.display = 'none';
        popupInfo.textContent = '';
        wordTranslationPopup.classList.add('visible');
        wordTranslationPopup.setAttribute('aria-hidden', 'false');
        
        // Fetch definition (only works well for English words)
        const defData = currentLangCode === 'en' ? await fetchDefinition(word) : null;
        
        if (defData && defData.definition) {
          const pos = defData.partOfSpeech ? `(${defData.partOfSpeech}) ` : '';
          popupDefinition.textContent = pos + defData.definition;
        } else if (currentLangCode === 'en') {
          popupDefinition.textContent = 'Definition not available';
        } else {
          popupDefinition.textContent = '';
        }
        
        // If showTranslation or if the text is not in English, show translation
        if (showTranslation || currentLangCode !== 'en') {
          // Determine translation direction
          let translatedText;
          if (currentLangCode !== 'en') {
            // Translate FROM current language TO English
            translatedText = await fetchTranslationFromTo(word, currentLangCode, 'en');
            if (translatedText) {
              popupTranslation.textContent = `English: ${translatedText}`;
              popupTranslation.style.display = 'block';
              // If no definition was available, use "tap again for definition" hint
              if (!defData || !defData.definition) {
                popupDefinition.textContent = `"${word}" ‚Üí "${translatedText}"`;
              }
            } else {
              popupTranslation.textContent = 'Translation not available';
              popupTranslation.style.display = 'block';
            }
          } else if (targetLangCode !== 'en') {
            // Translate FROM English TO native language
            translatedText = await fetchTranslation(word, targetLangCode);
            if (translatedText) {
              popupTranslation.textContent = `${targetLangTitle}: ${translatedText}`;
              popupTranslation.style.display = 'block';
            } else {
              popupTranslation.textContent = `${targetLangTitle}: Translation not available`;
              popupTranslation.style.display = 'block';
            }
          }
        }
        
        // Auto-hide after 6 seconds
        wordTranslationTimeout = setTimeout(hideWordTranslation, 6000);
      }
      
      async function fetchTranslationFromTo(word, fromLang, toLang) {
        try {
          const url = `https://api.mymemory.translated.net/get?q=${encodeURIComponent(word)}&langpair=${fromLang}|${toLang}`;
          const response = await fetch(url);
          if (!response.ok) return null;
          const data = await response.json();
          if (data && data.responseData && data.responseData.translatedText) {
            const translated = data.responseData.translatedText;
            if (translated.toLowerCase().includes('invalid') || 
                translated.toLowerCase().includes('error') ||
                translated === word) {
              return null;
            }
            return translated;
          }
          return null;
        } catch (err) {
          return null;
        }
      }

      // Text selection-based lookup
      let selectionTimeout = null;
      
      function handleTextSelection() {
        const selection = window.getSelection();
        const selectedText = selection.toString().trim();
        
        // Only process if there's selected text and it's within the story body
        if (!selectedText || selectedText.length === 0 || selectedText.length > 100) {
          return;
        }
        
        // Check if selection is within story body
        if (!selection.rangeCount) return;
        const range = selection.getRangeAt(0);
        if (!storyBody.contains(range.commonAncestorContainer)) {
          return;
        }
        
        // Get the bounding rect of the selection
        const rect = range.getBoundingClientRect();
        if (rect.width === 0 && rect.height === 0) return;
        
        // Clear any existing timeout
        if (selectionTimeout) {
          clearTimeout(selectionTimeout);
        }
        
        // Show popup with a small delay to avoid flickering during selection
        selectionTimeout = setTimeout(() => {
          showSelectionDefinition(rect, selectedText, true);
        }, 300);
      }
      
      // Listen for selection changes
      document.addEventListener('selectionchange', () => {
        const selection = window.getSelection();
        const selectedText = selection.toString().trim();
        
        if (!selectedText || selectedText.length === 0) {
          // Clear timeout if selection is cleared
          if (selectionTimeout) {
            clearTimeout(selectionTimeout);
            selectionTimeout = null;
          }
          return;
        }
      });
      
      // Handle mouseup to detect when selection is complete
      storyBody.addEventListener('mouseup', () => {
        handleTextSelection();
      });
      
      // Handle touchend for mobile
      storyBody.addEventListener('touchend', () => {
        // Small delay to let the selection be finalized
        setTimeout(handleTextSelection, 100);
      });

      // Hide popup when clicking elsewhere (but not when selecting text)
      document.addEventListener('mousedown', (e) => {
        if (!wordTranslationPopup.contains(e.target)) {
          hideWordTranslation();
        }
      });

      function onLanguageChange() {
        updateFloatingBtnLabel();
        cachedOtherLangContent = null;
        cachedOtherLangId = null;
      }

      // Register the language change callback for the floating button
      onLanguageChangeCallback = onLanguageChange;

      updateAudioButton();
      updateVersionFooter();
      applyTextSize();
      applyTheme();
      updateBookmarkStatus();
      applyFloatingButtonVisibility();
      updateFloatingBtnLabel();
      loadLibrary();
    </script>
  </body>
</html>
